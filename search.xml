<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2019년도의 회고 그리고 반성</title>
      <link href="/2019/12/31/2019-retrospect/"/>
      <url>/2019/12/31/2019-retrospect/</url>
      
        <content type="html"><![CDATA[<h1 id="서론"><a href="#서론" class="headerlink" title="서론"></a>서론</h1><p>길고 길던 2019년이 지났고, 나는 마침내 군대+휴학 포함 8년을 다니던 대학교를 졸업한다. 대학생의 나는 그다지 만족스러운 생활을 보내지 못한 것 같아 아쉬운 마음이 든다. 끝끝내 성적 괜찮고 취업도 괜찮은 곳으로 들어간 것 같지만, 아쉬운 점이 많은 대학 생활이었다고 생각한다.</p><p>하지만, 이미 지난 것을 어찌하겠는가. 뒤를 돌아보지 말고 앞으로 잘해내가면 된다고 믿는다.</p><h1 id="한-일들"><a href="#한-일들" class="headerlink" title="한 일들"></a>한 일들</h1><h2 id="1-2월"><a href="#1-2월" class="headerlink" title="1~2월"></a>1~2월</h2><p>1~2월에는 <strong>라인</strong>에서 인턴을 했다. Netty 개발자로 유명하신 <strong>희승</strong>님이 개발하고 계시는 <a href="https://github.com/line/armeria">Armeria</a> 라고하는 오픈소스를 개발하는 팀에 들어가서 기여하는 프로젝트를 했다. (생애 처음으로 오픈소스에 기여를 해보았다.)<br>오픈소스에는 생각보다 많은 노력과 관심을 필요로 한다. Pull Request를 보내면 거기서 부터 시작이다. 개인적으로 오픈소스에 기여하시는 분은 대단하다고 생각이 든다. </p><p>비록 지금은 좀 많이 다른 분야를 택하게 되서 그 팀에 가서 일할 수는 없지만, 인턴 기간동안 희승님을 만나서 같이 일해본 것은 뜻깊은 경험이었다. 희승님 실력이야 당연히 좋으시지만, 내가 꽤나 감명깊게 본 것은 커뮤니케이션 능력이 아닌가 싶다. 그 정도 실력, 높이에 있으면 어느정도 자만을 하는 경우가 많은데, 그런 느낌을 못느꼈고, 어떤 사람이 와서도 잘 이끌어 주실 것 같은 느낌이 들었다.</p><p>나머지 팀원 분들도 굉장히 실력있고 좋은 분들이었기에 인턴 생활을 꽤나 즐겁게 할 수 있었던것 같다. </p><table><thead><tr><th align="center"><img src="../img/pr.png" alt="img_pr"></th></tr></thead><tbody><tr><td align="center"><em>인턴기간 동안 했던 Pull Request 들..</em></td></tr></tbody></table><h1 id="3월-6월"><a href="#3월-6월" class="headerlink" title="3월 ~ 6월"></a>3월 ~ 6월</h1><p>4학년 1학기, 딱히 크게 기억이 남는 것은 없다. <del>추후에 나를 꽤나 괴롭힌 ~</del><em>RealGraph</em> 라고하는 졸업프로젝트를 시작했고 삼성 리서치, 라인 인턴 전환 면접을 보았다.</p><p>둘 다 결과는 좋지 않았다. 삼성 리서치는 직무와 창의 면접은 아주 좋게 봤으나, 임원 면접을 너무 망쳐버렸고 ( 삼성은 임원 면접의 비율이 높다고 하는데, 사실인가 보다. ), 라인 인턴 전환 면접은 내가 준비를 제대로 하지 못했다. (라인은 인턴 전환의 비율이 많이 낮다고 한다.)</p><p>사실 3월 부터의 느낌은 이미 안좋았던것 같다. (<del>올해는 뭔가 망한 느낌</del>) 개인적인 사건 사고도 여러 터졌었고, 이때부터 올해 내내 근심과 우울증에 시달렸던 것 같다.</p><h1 id="7월-8월"><a href="#7월-8월" class="headerlink" title="7월 ~ 8월"></a>7월 ~ 8월</h1><p>4학년 마지막 여름방학은, 내가 가장 후회하는 방학이 아닌가 싶다. 정말 거의 기억이 없다. 스터디 몇개를 했지만, 다 어영부영 하다가 끝나버렸고, 독일 스타트업과 카카오 프론트앤드 경력직 면접을 봤는데 결과가 역시 좋지 않았다.</p><p>사실 이때 토플이나 GRE 준비를 했어야 했다. 내 마음은 대학원을 갈지 취업을 할지 계속 고민 하는 상태였고, 졸업프로젝트 있다고 해서 할 수 있음에도 계속 시간이 없다는 핑계를 댄것 같다. 결국 나는 취업도 대학원 준비도 제대로 하지 못한채 방학을 끝냈다.</p><h1 id="9월-12월"><a href="#9월-12월" class="headerlink" title="9월 ~ 12월"></a>9월 ~ 12월</h1><p>9월 부터는 제대로된 취업 준비를 시작했다. 여러번 면접을 봤던 자료와 부족한 점을 모아서 뭐가 부족한지 고민해보고 보충했다. 삼성 같은 우리나라 3대 대기업 같은 곳은 내가 원하지 않았고, 네이버, 카카오, 스타트업 위주로 지원을 했다. 네이버는 공채와 교수님의 추천으로 하는 전환 인턴, 카카오는 공채를 지원(카카오 브레인)하게 되었다. 스타트업은 외국에 여러 지사를 가지고 있는 M사 시애틀 지점으로 지원을 했다.</p><p>결과는 네이버 공채를 제외한 모두 통과할 수 있었다. 결과적으로 카카오브레인으로 가기로 결정 했다. </p><p>카카오브레인을 결정한 이유는 앞으로의 진로를 인공지능쪽으로 결정했기 때문이다. 물론 대학원을 갈 수도 있지만, 굳이 이미 그쪽으로 취업한 거 대학원을 갈 필요가 있을까 생각했다.</p><p>특히나, 대학원은 별 생각없이 가는 곳이 아니다. 아직까지 나는 뭘 연구를 하고 싶은지, 어떤 걸 하고 싶은지 구체적인 플랜이 없으면 석사를 해도 별 의미가 없을 것이다. 그게 정해져야 대학원을 가야할지 말아야 할지 생각해야 하는게 아닐까?</p><h1 id="성공한-것"><a href="#성공한-것" class="headerlink" title="성공한 것"></a>성공한 것</h1><p>올해 뿐만 아니라, 대학교 내내 그나마 성공한 것은 성적이 아닐까 싶다. (사실 이것도 대학원 가는게 없으면 그다지 필요가 없다..)</p><p>그리고 아마.. 취업?</p><p>딱히 이번 년도에 성공한 게 없다.</p><h1 id="실패한-것"><a href="#실패한-것" class="headerlink" title="실패한 것"></a>실패한 것</h1><ol><li>운동</li></ol><ul><li>그냥 안했다. 그냥 내가 게을러서 그렇다.</li></ul><ol start="2"><li>대학원 준비</li></ol><ul><li>그냥 각만 재다가 아무것도 안했다. <del>나는 참 한심하구나</del></li></ul><ol start="3"><li>공부</li></ol><ul><li>학과 공부말고는 딱히 아무것도 안한 것 같다.</li></ul><ol start="4"><li>졸업프로젝트</li></ol><ul><li>졸업프로젝트는 프로젝트 말고 논문을 골랐어야 한다. 그래야 남는게 있다.</li></ul><h1 id="나는-왜-실패-했는가"><a href="#나는-왜-실패-했는가" class="headerlink" title="나는 왜 실패 했는가."></a>나는 왜 실패 했는가.</h1><p>나는 왜 실패했는가 올해 마지막으로 고민해본다.</p><ol><li>독학 (비강제성), 의지박약, 게으름, 열정 부족<ul><li>고등학교 때의 나는, 굉장히 부지런했는데, 난 왜 이렇게 된걸까?, 아마 자발적으로 공부하는 습관이 없어서 그렇게 된게 아닐까 싶다. 일단 지르고 강제적으로 할 수 있는 수단을 찾아야 겠다. 일단 집에서 벗어나야 한다.</li></ul></li><li>우유부단<ul><li>올해의 나는 백앤드로 갈거냐, 머신러닝으로 갈거냐를 계속 고민했고, 또 대학원이냐 취업이냐를 계속 고민해왔다. 물론 중요한 것이지만, 굳이 이렇게 오래 고민할 필요가 있엇을까?</li></ul></li></ol><h1 id="앞으로는"><a href="#앞으로는" class="headerlink" title="앞으로는"></a>앞으로는</h1><ol><li>일단 지르고 보자<ul><li>고민을 줄이고 일단 지르자. 너무 빡빡한 스케줄이 무리라고 하면 잠을 줄여버려야지</li></ul></li><li>운동<ul><li>일단 득근보다는 기초체력이 먼저 인것 같다. 기초 체력 기르기를 위주로 운동을 해야겠다.</li></ul></li><li>집을 벗어나쟈<ul><li>진심 이게 제일 중요함. 회사에서 그냥 일하고 공부하면서 살아야 겠다.</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> retrospect </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SWE &amp; ML Collections</title>
      <link href="/2019/12/27/swe-ml-collection/"/>
      <url>/2019/12/27/swe-ml-collection/</url>
      
        <content type="html"><![CDATA[<h1 id="주요-사이트"><a href="#주요-사이트" class="headerlink" title="주요 사이트"></a>주요 사이트</h1><ul><li><a href="https://deeplearning.ai">deeplearning.ai</a></li><li><a href="https://www.kakaobrain.com/">카카오브레인</a></li><li><a href="https://paperswithcode.com/sota">State-of-the-Art for dl</a></li><li><a href="https://www.44bits.io/ko">44bits.io/ko</a></li></ul><h1 id="도움되는-글-AI"><a href="#도움되는-글-AI" class="headerlink" title="도움되는 글 (AI)"></a>도움되는 글 (AI)</h1><ul><li><a href="https://blog.deeplearning.ai/blog/the-batch-biggest-ai-stories-of-2019-driverless-cars-stall-deepfakes-go-mainstream-face-recognition-gets-banned?fbclid=IwAR1U0TCCvW9giK3KacoyOsPcXo-cxA-Fx1cE9hxPYvxwyV5we1LGzfAup5c">AI 최신 동향</a></li><li><a href="https://gomcine.tistory.com/entry/%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D-%EA%B3%B5%EB%B6%80-%EC%88%9C%EC%84%9C-%EB%B0%8F-%EB%B0%A9%EB%B2%95-%EA%B0%95%EC%9D%98-%EC%A0%95%EB%A6%AC?fbclid=IwAR1OOMGfcCtEfjoQ6sEkknaYDDkmO6pHfazxvyczkIHX4lLy745q-WwdWes">머신러닝 공부순서</a></li><li><a href="https://huyenchip.com/2019/12/18/key-trends-neurips-2019.html?fbclid=IwAR3h-X-iJ3ba-3XWusHvPnwd5pu4LQEXLSekFu6DgnFmLVs4pOq0XZ-TdNw">Key trends from NeurIPS 2019</a></li><li><a href="https://zzsza.github.io/data/2019/12/15/rules-of-ml/?fbclid=IwAR2RS_x1Q-e3PReVK64fjQrNYhWS2wU_3QKepI2UaWaYb6uX1RufD4rTstE">Rules of Machine Learning: Best Practices for ML Engineering</a></li><li><a href="https://jameskle.com/writes/deep-learning-infrastructure-tooling?fbclid=IwAR1w9lm3RKUVkAJqNTbIa-l8-W1jsZ7qknkLwRBjkvHZX5e6NNmjjg3DOR4">Fullstack of Deep learning, 딥러닝 레퍼런스</a></li><li><a href="https://papers.nips.cc/paper/9015-pytorch-an-imperative-style-high-performance-deep-learning-library?fbclid=IwAR3HbBnYpKeaK2-w5BctX2ec-GyszHVng-Q66UpOv_XMaLXhbhnUDXTuKnQ">Pytorch 논문</a></li><li><a href="https://landscape.lfai.foundation/?fbclid=IwAR1km-3ABrHtewr1fGOS-bNNrU2gizu2Q6UXrSRbiiKyESdWBePWf9n6ZUM">LF AI Foundation Interactive Landscape</a></li><li><a href="http://www.datamarket.kr/xe/board_fpbt85/55766?fbclid=IwAR0CvOXc3HWz_abD_GrIBX7Xf3_JtzPnNEEkm_15-BkNP4R07bCfy5j7CGs">인공지능, 통계 관련 유용한 무료 강의 &amp; 책 모음</a></li><li><a href="https://media-ai.tistory.com/7?fbclid=IwAR3MEUuH9x0ydCeq3o1c3BdrJAZOrV2xtWCyoB7wgpgwlsNENBfdLYZQAKc">논문 읽기와 ML/DL 커리어 경력에 대한 조언 by Andrew Ng</a></li><li><a href="https://www.youtube.com/watch?v=09_LlHjoEiY&feature=youtu.be&fbclid=IwAR2TMC3DHQ9Z69xBSnP2hjR6g_1XqW8cDO6sl05_KoPflBMnAeJ8-XqSlnY">Graph Theory Algorithms</a></li><li><a href="http://soopsaram.com/ml/?fbclid=IwAR1MXTnvg9wk1nk2kfhO2RbdFtylMn4vsDIfQfwVlVv9HmtNONtez6TqLs4">Machine Learning 정리</a></li></ul><h1 id="도움-되는-글-SWE"><a href="#도움-되는-글-SWE" class="headerlink" title="도움 되는 글 (SWE)"></a>도움 되는 글 (SWE)</h1><ul><li><a href="https://www.44bits.io/ko/post/how-docker-image-work?fbclid=IwAR1nd-3eII-DJ-WHwj1xFhQSNxsdfEUIkPt6pIoY-GNMnuW65cS664BtLvA">만들면서 이해하는 도커 이미지의 구조</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ai </category>
          
      </categories>
      
      
        <tags>
            
            <tag> machine-learning </tag>
            
            <tag> deep-learning </tag>
            
            <tag> swe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020년의 계획</title>
      <link href="/2019/12/27/2020-resolution/"/>
      <url>/2019/12/27/2020-resolution/</url>
      
        <content type="html"><![CDATA[<h1 id="올해-전반-계획"><a href="#올해-전반-계획" class="headerlink" title="올해 전반 계획"></a>올해 전반 계획</h1><ul><li>논문 읽기 스터디 (매주)</li><li>leetcode 화이트 보드 연습</li><li>배운 것들을 블로그에 써가는 습관</li><li>운동 ( 기초 체력 단련 위주 )</li><li>1일 1커밋</li></ul><h1 id="1월-3월"><a href="#1월-3월" class="headerlink" title="1월 ~ 3월"></a>1월 ~ 3월</h1><ul><li>풀잎교실 수학 수업</li></ul><h1 id="4월-10월"><a href="#4월-10월" class="headerlink" title="4월 ~ 10월"></a>4월 ~ 10월</h1><ul><li><a href="https://www.coursera.org/specializations/aml?recoOrder=6&utm_medium=email&utm_source=recommendations&utm_campaign=8ml6oCXHEeqnEClWfXMgdQ#faq">Coursera, Advanced Machine Learning</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> resolution </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/06/01/hello-world/"/>
      <url>/2019/06/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> hello </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hello </tag>
            
            <tag> first </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Longest Consecutive Sequence</title>
      <link href="/2019/05/29/2019-05-29-leetcode-128/"/>
      <url>/2019/05/29/2019-05-29-leetcode-128/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/longest-consecutive-sequence/">Longest Consecutive Sequence</a></p><h2 id="Solution-1-Hash-set-and-intelligent-sequence-building"><a href="#Solution-1-Hash-set-and-intelligent-sequence-building" class="headerlink" title="Solution 1. Hash set and intelligent sequence building"></a>Solution 1. Hash set and intelligent sequence building</h2><p>배열에 있는 모든 수를 우선 Hash Set에다가 넣는다. 그리고 하나씩 조회하면서 그 이전수 예를 들어 5를 조회 한다고 가정하면 4가 현재 Set에 있는지 확인한다. 없으면 해당 숫자가 시퀀스의 맨 처음 숫자인 것이라고 할 수 있다. 이때 그 숫자부터 시작하여 몇개의 숫자가 연속되어 있는지 세기만 하면 된다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; sets;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s : nums) &#123;</span><br><span class="line">            sets.insert(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s : sets) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s == INT_MIN || sets.find(s<span class="number">-1</span>) == sets.end()) &#123;</span><br><span class="line">                <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(s != INT_MAX &amp;&amp; sets.find(s++) != sets.end()) cnt++;</span><br><span class="line">                ans = max(ans, cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Triangle</title>
      <link href="/2019/05/23/2019-05-23-leetcode-120/"/>
      <url>/2019/05/23/2019-05-23-leetcode-120/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/triangle/">Triangle</a></p><h2 id="Solution-1-Recursion-TLE"><a href="#Solution-1-Recursion-TLE" class="headerlink" title="Solution 1. Recursion (TLE)"></a>Solution 1. Recursion (TLE)</h2><p>가장 무식하면서도 간단한 방법은 Recursion을 이용해 모든 경우의 수를 다 돌아 보는 것이다.</p><p>현재 위치가 y, x에 있다면, y+1,x+1에서 갈때의 최소값과 y+1, x에서 갈때의 최소값을 비교해서 작은 것을 선택하면 된다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle, <span class="keyword">int</span> height, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur &lt; <span class="number">0</span> || cur &gt;= triangle[height].size()) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(height == triangle.size()<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> triangle[height][cur];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> triangle[height][cur] +</span><br><span class="line">            min(minimumTotal(triangle, height+<span class="number">1</span>, cur), minimumTotal(triangle, height+<span class="number">1</span>, cur+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> minimumTotal(triangle, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>하지만 이렇게 하면 TLE가 난다. 너무 느리다. 최적화가 필요하다.</p><h2 id="Solution-2-Recursion-Cacheing"><a href="#Solution-2-Recursion-Cacheing" class="headerlink" title="Solution 2. Recursion + Cacheing"></a>Solution 2. Recursion + Cacheing</h2><p>겹치는 부분을 잘 살펴보자. 예를 들어 다음과 같은 트라이앵글이 존재한다고 가정하자</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">     [<span class="number">2</span>],</span><br><span class="line">    [<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">   [<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>예를 들어 2번째 줄인 3,4 는 5를 공유한다. 따라서 3에서 이미 값을 구했다면 4에서는 이를 구할 필요가 없다. 이를 잘 저장하고 있다가 다시 쓰면 굳이 다시 구하지 않아도 된다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; cache, <span class="keyword">int</span> height, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur &lt; <span class="number">0</span> || cur &gt;= triangle[height].size()) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(cache[height].size() &lt;= cur) cache[height].push_back(INT_MAX);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(height == triangle.size()<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> triangle[height][cur];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cache[height][cur] != INT_MAX) &#123;</span><br><span class="line">            <span class="keyword">return</span> cache[height][cur];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cache[height][cur] = triangle[height][cur] +</span><br><span class="line">            min(minimumTotal(triangle,cache, height+<span class="number">1</span>, cur), minimumTotal(triangle,cache, height+<span class="number">1</span>, cur+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; cache;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;triangle.size();i++) &#123;</span><br><span class="line">            cache.push_back(&#123;&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minimumTotal(triangle,cache, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Time complexity, Space complexity는 O(n) 이 된다, (n은 모든 원소의 개수이다.)</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Permutation in String</title>
      <link href="/2019/05/22/2019-05-22-leetcode-567/"/>
      <url>/2019/05/22/2019-05-22-leetcode-567/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/permutation-in-string/">Permutation in String</a></p><h2 id="Solution-Sliding-window"><a href="#Solution-Sliding-window" class="headerlink" title="Solution : Sliding window"></a>Solution : Sliding window</h2><p>S1과 S2 각각 알파벳 빈도수를 구하고 이를 오른쪽으로 Sliding 하면서 계속 비교해준다.<br>알파벳이 아니라면 int 배열 대신 <strong>unordered_map</strong> 을 사용하면 되겠지만 문제에서는 알파벳만 사용했기때문에 int 배열을 사용하는게 좋다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maps[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> maps2[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(s1.size() &gt; s2.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s1.size();i++) &#123;</span><br><span class="line">            maps[s1[i]-<span class="string">'a'</span>] += <span class="number">1</span>;</span><br><span class="line">            maps2[s2[i]-<span class="string">'a'</span>] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">26</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(maps[i] == maps2[i]) cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">26</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=s1.size();i &lt; s2.size();i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = s2[i-s1.size()] - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">int</span> d = s2[i] - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(maps[c] == maps2[c]) &#123;</span><br><span class="line">                cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(maps[d] == maps2[d]) &#123;</span><br><span class="line">                cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">            maps2[c]--;</span><br><span class="line">            maps2[d]++;</span><br><span class="line">            <span class="keyword">if</span>(maps[c] == maps2[c]) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(maps[d] == maps2[d]) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">26</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt == <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>O(S2)</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Surrounded Regions</title>
      <link href="/2019/05/18/2019-05-18-leetcode-130/"/>
      <url>/2019/05/18/2019-05-18-leetcode-130/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/surrounded-regions/">Surrounded Regions</a></p><h2 id="Solution-1-BFS"><a href="#Solution-1-BFS" class="headerlink" title="Solution 1. BFS"></a>Solution 1. BFS</h2><p>간단하게 BFS를 이용하면 해결되는 문제이다. 우선 X로 둘러 싸여져 있지 않다는 의미는 무엇일까? </p><p>그것은 바로 어떤 O 하나 혹은 여러개가 보드 가장자리에 있다는 것이다. 즉, O를 만나면 BFS로 탐색하여 이 가장자리가 있는 O를 발견하지 않으면 방문했던 노드들을 flip 시켜주면 된다. 이미 방문 했던 노드들은 V라는 문자로 바꿔주었다</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canMove</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> y,<span class="keyword">int</span> x, <span class="keyword">bool</span> flip)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (y &gt;= <span class="number">0</span> &amp;&amp; y &lt; board.size()) &amp;&amp; (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; board[<span class="number">0</span>].size()) &amp;&amp; ((!flip &amp;&amp; board[y][x] == <span class="string">'O'</span>) || (flip &amp;&amp; board[y][x] == <span class="string">'V'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> y, <span class="keyword">int</span> x, <span class="keyword">bool</span> flip)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> ret = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.push(make_pair(y,x));</span><br><span class="line">        board[y][x] = flip ? <span class="string">'X'</span> : <span class="string">'V'</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(!flip) &#123;</span><br><span class="line">                <span class="keyword">if</span>(p.first == <span class="number">0</span> || p.second == <span class="number">0</span> || p.first == board.size()<span class="number">-1</span> || p.second == board[<span class="number">0</span>].size()<span class="number">-1</span>) &#123;</span><br><span class="line">                    ret = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(canMove(board, p.first+<span class="number">1</span>, p.second,flip)) &#123;</span><br><span class="line">                q.push(make_pair(p.first+<span class="number">1</span>, p.second));</span><br><span class="line">                board[p.first+<span class="number">1</span>][p.second] = flip ? <span class="string">'X'</span> : <span class="string">'V'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(canMove(board, p.first<span class="number">-1</span>, p.second,flip)) &#123;</span><br><span class="line">                q.push(make_pair(p.first<span class="number">-1</span>, p.second));</span><br><span class="line">                board[p.first<span class="number">-1</span>][p.second] = flip ? <span class="string">'X'</span> : <span class="string">'V'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(canMove(board, p.first, p.second+<span class="number">1</span>,flip)) &#123;</span><br><span class="line">                q.push(make_pair(p.first, p.second+<span class="number">1</span>));</span><br><span class="line">                board[p.first][p.second+<span class="number">1</span>] = flip ? <span class="string">'X'</span> : <span class="string">'V'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(canMove(board, p.first, p.second<span class="number">-1</span>,flip)) &#123;</span><br><span class="line">                q.push(make_pair(p.first, p.second<span class="number">-1</span>));</span><br><span class="line">                board[p.first][p.second<span class="number">-1</span>] = flip ? <span class="string">'X'</span> : <span class="string">'V'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;board.size();i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; v = board[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;v.size();j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(v[j] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(bfs(board, i, j, <span class="literal">false</span>)) &#123;</span><br><span class="line">                        bfs(board, i, j, <span class="literal">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;board.size();i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;board[i].size();j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'V'</span>) board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="잘못-짯던-부분"><a href="#잘못-짯던-부분" class="headerlink" title="잘못 짯던 부분"></a>잘못 짯던 부분</h2><p>BFS를 가지고 Q를 이용해 탐색시에는 <strong>큐에 넣은 후에 Visited 체크를 꼭 해주자.</strong> 안그러면 타임아웃</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Construct Binary Tree from Preorder and Inorder Traversal</title>
      <link href="/2019/04/29/2019-04-29-leetcode-105/"/>
      <url>/2019/04/29/2019-04-29-leetcode-105/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">Construct Binary Tree from Preorder and Inorder Traversal</a></p><h2 id="Solution-Recursion"><a href="#Solution-Recursion" class="headerlink" title="Solution : Recursion"></a>Solution : Recursion</h2><p>Preorder과 Inorder를 가지고 트리를 구성하기 위해서는 Recursion과 각각 순회방법에 대한 특징에 대한 이해가 필요하다.</p><p>Preorder 의 경우 부모 - left - right 순서이고, Inorder 는 left - 부모 - right 순서이다.</p><p>그렇다면 잘 생각해보면, preorder 순서의 제일 왼쪽의 있는 요소는 현재 트리의 루트라고 할 수 있다.</p><p>그리고 그 루트를 inorder 배열에서 찾는다. 이때 찾은 인덱스를 c라고 하면,<br>0<del>c-1까지가 left 서브트리의 inorder이고, c+1</del>끝까지가 right 서브트리의 inorder이다.</p><p>그리고 preorder에서 다음 index는 left 서브트리의 루트 혹은 서브트리가 없을 경우(c == 0) right 서브트리의 루트라고 할 수 있다.</p><p>이를 통하여 트리를 만들 수 있다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> buildTree(preorder, inorder, <span class="number">0</span>, preorder.size()<span class="number">-1</span>, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> s, <span class="keyword">int</span> e, <span class="keyword">int</span>&amp; k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s &gt; e || k &gt;= preorder.size()) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> TreeNode(preorder[k]);</span><br><span class="line">    <span class="keyword">int</span> c = s;</span><br><span class="line">    <span class="keyword">while</span>(c &lt;= e &amp;&amp; preorder[k] != inorder[c]) c++;</span><br><span class="line">    k++;</span><br><span class="line">    root-&gt;left = buildTree(preorder, inorder, s, c<span class="number">-1</span>, k);</span><br><span class="line">    root-&gt;right = buildTree(preorder, inorder ,c+<span class="number">1</span>, e, k);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>참고로, preorder과 inorder의 index는 다름을 주의하자. 많이 헷갈린다.</p><h2 id="Related"><a href="#Related" class="headerlink" title="Related"></a>Related</h2><p><a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">leetcode 106</a></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Convert Sorted List to Binary Search Tree</title>
      <link href="/2019/04/24/2019-04-24-leetcode-109/"/>
      <url>/2019/04/24/2019-04-24-leetcode-109/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree">Convert Sorted List to Binary Search Tree</a></p><h2 id="Solution-1-Convert-To-Array-and-Recursion-afterward"><a href="#Solution-1-Convert-To-Array-and-Recursion-afterward" class="headerlink" title="Solution 1: Convert To Array and Recursion afterward"></a>Solution 1: Convert To Array and Recursion afterward</h2><p>입력이 LinkedList 로 주어진다. 잘 생각해보면 정렬된 배열 -&gt; BST로 바꾸는 것은 간단하다. 해당 배열의 맨 중간 값을 현재 노드의 값으로 선택하고 왼쪽 서브 배열, 오른쪽 서브 배열에 대해서 각각 Recursion으로 해결해주면 된다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            v.push_back(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sortedListToBST(v, <span class="number">0</span>, v.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v, <span class="keyword">int</span> s, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(v[s]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(s &gt; e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = (s+e)/<span class="number">2</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(v[m]);</span><br><span class="line">        root-&gt;left = sortedListToBST(v, s, m<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = sortedListToBST(v, m+<span class="number">1</span>, e);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>시간복잡도는 따라서 O(n)이 된다. </p><h2 id="Solution-2-Recursion"><a href="#Solution-2-Recursion" class="headerlink" title="Solution 2: Recursion"></a>Solution 2: Recursion</h2><p>2번은 1번의 경우와 비슷하지만 배열로 변환하지 않은 버전이다.</p><p>1번 솔루션과 비슷하다. 단지 다른 점이라고 하면 루트를 먼저 만드는게 아니라 노드의 left를 먼저 구하고 root를 설정하고 right를 구한다.</p><p>이를 recursive 하게 진행하면 된다.</p><p>이 방법은 단번에 생각해내기 어렵다..</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedListToBST</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">            c++;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> makeBST(head, <span class="number">0</span>, c - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">makeBST</span><span class="params">(ListNode*&amp; head, <span class="keyword">int</span> s,<span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s &gt; e) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (s+e)/<span class="number">2</span>;</span><br><span class="line">        TreeNode* left = makeBST(head, s, mid<span class="number">-1</span>);</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(head-&gt;val);</span><br><span class="line">        root-&gt;left = left;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        root-&gt;right = makeBST(head, mid+<span class="number">1</span>, e);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Time complexity 는 O(n) 이다. 이는 Solution 1과 같지만 Space Complexity가 O(1)으로 O(n)인 1번 솔루션에 비해 더 좋다고 할 수 있다.</p><h2 id="관련-지식"><a href="#관련-지식" class="headerlink" title="관련 지식"></a>관련 지식</h2><p>다음 3가지의 트리 순회 방법에 대해서 제대로 숙지하는 것이 좋을 것 같다.</p><ul><li>Inorder</li><li>Preorder</li><li>Postorder</li></ul>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Binary Tree Level Order Traversal</title>
      <link href="/2019/04/23/2019-04-23-leetcode-102/"/>
      <url>/2019/04/23/2019-04-23-leetcode-102/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/binary-tree-level-order-traversal">Binary Tree Level Order Traversal</a></p><h2 id="Solution-1-Recursive"><a href="#Solution-1-Recursive" class="headerlink" title="Solution 1. Recursive"></a>Solution 1. Recursive</h2><p>이 문제는 Medium 이지만 Easy에 가깝다.</p><p>재귀적 방법을 이용하면 풀 수 있다. </p><p>2차원 배열 vector를 선언하고</p><p>현재 노드의 레벨을 lv라고 했을 때 현재 lv 만큼의 버켓이 없다면 버켓을 생성해주고, lv 인덱스 버켓에 현재 노드의 값을 저장한다.</p><p>이 과정을 왼쪽과 오른쪽 노드에도 똑같이 반복하면 된다.</p><p>소스코드는 다음과 같다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; buckets;</span><br><span class="line">    levelOrder(root, buckets, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> buckets;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; buckets, <span class="keyword">int</span> lv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span>(buckets.size() &lt;= lv) buckets.push_back(&#123;&#125;);</span><br><span class="line">    buckets[lv].push_back(root-&gt;val);</span><br><span class="line">    levelOrder(root-&gt;left, buckets, lv+<span class="number">1</span>);</span><br><span class="line">    levelOrder(root-&gt;right, buckets, lv+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>시간복잡도는 n을 총 노드의 갯수라고 가정 했을 때 O(n)이 된다.</p><h2 id="Solution-2-Queue"><a href="#Solution-2-Queue" class="headerlink" title="Solution 2. Queue"></a>Solution 2. Queue</h2><p>두번째 해결방법은 Queue 두개를 이용한 방법이다. (사실 하나로도 해결할 수는 있지만 그냥 두개를 이용하는게 편하다.)</p><p>이는 BFS를 생각하면 된다. Q1에는 현재 레벨의 노드들이 들어가 있고, Q2에는 다음 레벨의 노드들을 차례대로 담는 것이다. 그리고 현재 레벨이 끝나면 Q2를 Q1으로 바꾸고 이를 반복하면 된다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; r;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> r;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; _q[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> lv = <span class="number">0</span>;</span><br><span class="line">    _q[<span class="number">0</span>].push(root);</span><br><span class="line">    <span class="keyword">while</span>(!_q[<span class="number">0</span>].empty() || !_q[<span class="number">1</span>].empty()) &#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; &amp;src = _q[lv % <span class="number">2</span>];</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; &amp;dst = _q[(lv+<span class="number">1</span>) % <span class="number">2</span>];</span><br><span class="line">        r.push_back(&#123;&#125;);</span><br><span class="line">        <span class="keyword">while</span>(!src.empty()) &#123;</span><br><span class="line">            TreeNode* c = src.front();</span><br><span class="line">            r[lv].push_back(c-&gt;val);</span><br><span class="line">            src.pop();</span><br><span class="line">            <span class="keyword">if</span>(c-&gt;left) dst.push(c-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(c-&gt;right) dst.push(c-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        lv++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>사실 이 방법이 1번 방법보다는 다소 복잡한 감이 없지않아 있지만 문제의 의도와는 비슷하다고 볼 수 있다.</p><h2 id="Related"><a href="#Related" class="headerlink" title="Related"></a>Related</h2><p><a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/">leetcode 103</a></p><h2 id="Advanced-Questions"><a href="#Advanced-Questions" class="headerlink" title="Advanced Questions?"></a>Advanced Questions?</h2><ol><li>결과 값은 다 메모리에 들어갈 수 있지만, 트리가 메모리 안에 들어갈 수 없다면 어떻게 할까?</li></ol><ul><li>메모리 안에 들어갈 수 없다면 별도로 chunk 별로 나누어서 저장해야 한다. 여기서 주의해야 할 점은 노드 정보에서 자식 노드들의 정보는 메모리 값이 아니라 파일 인덱스가 될 수도 있다는 점이다. 그리고 chunk를 저장하는 방법도 성능에 중요한 영향을 미칠 수 있다. 내 생각에는 $$2^n - 1$$개를 하나의 chunk로 삼아서 저장하면 될 거 같다. 예를들어 레벨이 총 6개까지 있을때 레벨 1<del>3 까지 1개의 chunk, 레벨 4</del>6까지 8개의 chunk가 생기므로 총 9개의 chunk가 생긴다고 생각 하면된다.</li></ul>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - Best Time to Buy and Sell Stock III</title>
      <link href="/2019/04/22/2019-04-22-leetcode-123/"/>
      <url>/2019/04/22/2019-04-22-leetcode-123/</url>
      
        <content type="html"><![CDATA[<p>Say you have an array for which the $i^{th}$ element is the place of a given stock on day <em>i</em>.</p><p>Design an algorithm to find the maximum profit. You may complete at most two transactions.</p><p><strong>Note:</strong> You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,3,5,0,0,3,1,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: Buy on day 4 (price &#x3D; 0) and sell on day 6(price &#x3D; 3), profit &#x3D; 3 - 9 &#x3D; 3, Then buy on day 7 (price &#x3D; 1) and sell on day 8 (price &#x3D; 4), profit &#x3D; 4 - 1 &#x3D; 3</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><h2 id="Solution-1-Brute-Force"><a href="#Solution-1-Brute-Force" class="headerlink" title="Solution 1. Brute Force"></a>Solution 1. Brute Force</h2><p>우선 가장 쉬운 문제 해결 방법은 <strong>Brute Force</strong> 방법이다. 이중 포문을 이용하여 첫번째 거래를 찾는다 (i &lt; j  &amp;&amp; prices[i] &lt; prices[j]) 그 다음 j+1부터 n-1까지 두번째 거래를 마찬가지로 이중 포문을 이용하여 찾는다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> maxProfit(prices, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices, <span class="keyword">int</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = s;i &lt; prices.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; prices.size();j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &lt; prices[j]) &#123;</span><br><span class="line">                ans = max(ans, prices[j]-prices[i] + maxProfit(prices, j+<span class="number">1</span>, k<span class="number">-1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>하지만, 이러한 방법은 시간복잡도가 O($$n^4$$) 가 된다는 단점이 있다.</p><h2 id="Solution-2-뒤에서-계산하기"><a href="#Solution-2-뒤에서-계산하기" class="headerlink" title="Solution 2. 뒤에서 계산하기"></a>Solution 2. 뒤에서 계산하기</h2><p>이 방법은 필자가 처음으로 생각해낸 방법이다. 뒤에서 부터 mx array를 계산하는 것이다.</p><p>여기서 mx array는 mx[i] = <strong>i 부터 시작한다고 가졍하고 한번만 거래하는 경우의 최대값</strong></p><p>이때 mx[i] = max( mx[i+1] , i~끝까지의 최대값 - prices[i] )<br>이다.</p><p>이렇게 구한 mx 배열을 이용해서 최대 두번 거래할때의 최대값을 구할 수 있다.</p><p>이는 0부터 시작하면서, i 번째 값은 $$profit_i = max(profit_{i-1}, mx[i+1] + prices[i] - mn)$$, 여기서 mn은 prices[0~i] 까지의 최소값</p><p>코드로 구현하면 다음과 같다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prices.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mx(prices.size()+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> cur_mx = INT_MIN, cur_mn = INT_MAX;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = prices.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        cur_mx = max(prices[i], cur_mx);</span><br><span class="line">        mx[i] = max(mx[i+<span class="number">1</span>], cur_mx - prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.size(); i++) &#123;</span><br><span class="line">        cur_mn = min(prices[i], cur_mn);</span><br><span class="line">        ans = max(ans, mx[i+<span class="number">1</span>] + prices[i] - cur_mn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 시간복잡도는 O($$n$$) 이고, 공간복잡도 역시 O($$n$$) 이다.<br>더 좋은 방법이 있을듯.</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Two Sum</title>
      <link href="/2019/04/05/2019-04-05-two-sum/"/>
      <url>/2019/04/05/2019-04-05-two-sum/</url>
      
        <content type="html"><![CDATA[<p>Given a sorted array of integers and an integer <code>n</code>, find a pair of elements which sum is <code>n</code>.<br>For example, Let’s say the array is <code>[1,2,4,5]</code> and <code>n</code> is 9, then the answer would be <code>[4,5]</code>.</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[l]+nums[r] &gt; sum) &#123;</span><br><span class="line">            r -= <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[l]+nums[r] == sum) &#123;</span><br><span class="line">            <span class="keyword">return</span> make_pair(nums[l], nums[r]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> make_pair(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Time-Complexity"><a href="#Time-Complexity" class="headerlink" title="Time Complexity"></a>Time Complexity</h1><p>since in every iteration, it moves forward or backward and it does until the left is greater than or equal to the right, the time complexity is <code>O(n)</code></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

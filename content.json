{"pages":[{"title":"","text":"Hello?","link":"/about.html"}],"posts":[{"title":"Binary Tree Level Order Traversal","text":"Binary Tree Level Order Traversal Solution 1. Recursive이 문제는 Medium 이지만 Easy에 가깝다. 재귀적 방법을 이용하면 풀 수 있다. 2차원 배열 vector를 선언하고 현재 노드의 레벨을 lv라고 했을 때 현재 lv 만큼의 버켓이 없다면 버켓을 생성해주고, lv 인덱스 버켓에 현재 노드의 값을 저장한다. 이 과정을 왼쪽과 오른쪽 노드에도 똑같이 반복하면 된다. 소스코드는 다음과 같다. 12345678910111213vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { vector&lt;vector&lt;int&gt;&gt; buckets; levelOrder(root, buckets, 0); return buckets;}void levelOrder(TreeNode* root, vector&lt;vector&lt;int&gt;&gt;&amp; buckets, int lv) { if(root == NULL) return; while(buckets.size() &lt;= lv) buckets.push_back({}); buckets[lv].push_back(root-&gt;val); levelOrder(root-&gt;left, buckets, lv+1); levelOrder(root-&gt;right, buckets, lv+1);} 시간복잡도는 n을 총 노드의 갯수라고 가정 했을 때 O(n)이 된다. Solution 2. Queue두번째 해결방법은 Queue 두개를 이용한 방법이다. (사실 하나로도 해결할 수는 있지만 그냥 두개를 이용하는게 편하다.) 이는 BFS를 생각하면 된다. Q1에는 현재 레벨의 노드들이 들어가 있고, Q2에는 다음 레벨의 노드들을 차례대로 담는 것이다. 그리고 현재 레벨이 끝나면 Q2를 Q1으로 바꾸고 이를 반복하면 된다. 123456789101112131415161718192021vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { vector&lt;vector&lt;int&gt;&gt; r; if(root == NULL) return r; queue&lt;TreeNode*&gt; _q[2]; int lv = 0; _q[0].push(root); while(!_q[0].empty() || !_q[1].empty()) { queue&lt;TreeNode*&gt; &amp;src = _q[lv % 2]; queue&lt;TreeNode*&gt; &amp;dst = _q[(lv+1) % 2]; r.push_back({}); while(!src.empty()) { TreeNode* c = src.front(); r[lv].push_back(c-&gt;val); src.pop(); if(c-&gt;left) dst.push(c-&gt;left); if(c-&gt;right) dst.push(c-&gt;right); } lv++; } return r;} 사실 이 방법이 1번 방법보다는 다소 복잡한 감이 없지않아 있지만 문제의 의도와는 비슷하다고 볼 수 있다. Relatedleetcode 103 Advanced Questions? 결과 값은 다 메모리에 들어갈 수 있지만, 트리가 메모리 안에 들어갈 수 없다면 어떻게 할까? 메모리 안에 들어갈 수 없다면 별도로 chunk 별로 나누어서 저장해야 한다. 여기서 주의해야 할 점은 노드 정보에서 자식 노드들의 정보는 메모리 값이 아니라 파일 인덱스가 될 수도 있다는 점이다. 그리고 chunk를 저장하는 방법도 성능에 중요한 영향을 미칠 수 있다. 내 생각에는 $$2^n - 1$$개를 하나의 chunk로 삼아서 저장하면 될 거 같다. 예를들어 레벨이 총 6개까지 있을때 레벨 13 까지 1개의 chunk, 레벨 46까지 8개의 chunk가 생기므로 총 9개의 chunk가 생긴다고 생각 하면된다.","link":"/2019/04/23/2019-04-23-leetcode-102/"},{"title":"LeetCode - Best Time to Buy and Sell Stock III","text":"Say you have an array for which the $i^{th}$ element is the place of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: 123Input: [3,3,5,0,0,3,1,4]Output: 6Explanation: Buy on day 4 (price = 0) and sell on day 6(price = 3), profit = 3 - 9 = 3, Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4 - 1 = 3 Example 2: 12Input: [1,2,3,4,5]Output: 4 Example 3: 12Input: [7,6,4,3,1]Output: 0 Solution 1. Brute Force우선 가장 쉬운 문제 해결 방법은 Brute Force 방법이다. 이중 포문을 이용하여 첫번째 거래를 찾는다 (i &lt; j &amp;&amp; prices[i] &lt; prices[j]) 그 다음 j+1부터 n-1까지 두번째 거래를 마찬가지로 이중 포문을 이용하여 찾는다. 12345678910111213141516int maxProfit(vector&lt;int&gt;&amp; prices) { return maxProfit(prices, 0, 2);}int maxProfit(vector&lt;int&gt;&amp; prices, int s, int k) { int ans = 0; if(k == 0) return 0; for(int i = s;i &lt; prices.size(); i++) { for(int j = i+1; j &lt; prices.size();j++) { if(prices[i] &lt; prices[j]) { ans = max(ans, prices[j]-prices[i] + maxProfit(prices, j+1, k-1)); } } } return ans;} 하지만, 이러한 방법은 시간복잡도가 O($$n^4$$) 가 된다는 단점이 있다. Solution 2. 뒤에서 계산하기이 방법은 필자가 처음으로 생각해낸 방법이다. 뒤에서 부터 mx array를 계산하는 것이다. 여기서 mx array는 mx[i] = i 부터 시작한다고 가졍하고 한번만 거래하는 경우의 최대값 이때 mx[i] = max( mx[i+1] , i~끝까지의 최대값 - prices[i] )이다. 이렇게 구한 mx 배열을 이용해서 최대 두번 거래할때의 최대값을 구할 수 있다. 이는 0부터 시작하면서, i 번째 값은 $$profit_i = max(profit_{i-1}, mx[i+1] + prices[i] - mn)$$, 여기서 mn은 prices[0~i] 까지의 최소값 코드로 구현하면 다음과 같다. 123456789101112131415int maxProfit(vector&lt;int&gt;&amp; prices) { if(prices.size() == 0) return 0; vector&lt;int&gt; mx(prices.size()+1); int cur_mx = INT_MIN, cur_mn = INT_MAX; int ans = 0; for(int i = prices.size() - 1; i &gt;= 0; i--) { cur_mx = max(prices[i], cur_mx); mx[i] = max(mx[i+1], cur_mx - prices[i]); } for(int i = 0; i &lt; prices.size(); i++) { cur_mn = min(prices[i], cur_mn); ans = max(ans, mx[i+1] + prices[i] - cur_mn); } return ans;} 여기서 시간복잡도는 O($$n$$) 이고, 공간복잡도 역시 O($$n$$) 이다.더 좋은 방법이 있을듯.","link":"/2019/04/22/2019-04-22-leetcode-123/"},{"title":"Convert Sorted List to Binary Search Tree","text":"Convert Sorted List to Binary Search Tree Solution 1: Convert To Array and Recursion afterward입력이 LinkedList 로 주어진다. 잘 생각해보면 정렬된 배열 -&gt; BST로 바꾸는 것은 간단하다. 해당 배열의 맨 중간 값을 현재 노드의 값으로 선택하고 왼쪽 서브 배열, 오른쪽 서브 배열에 대해서 각각 Recursion으로 해결해주면 된다. 1234567891011121314151617181920212223class Solution {public: TreeNode* sortedListToBST(ListNode* head) { vector&lt;int&gt; v; while(head != NULL) { v.push_back(head-&gt;val); head = head-&gt;next; } return sortedListToBST(v, 0, v.size()-1); } TreeNode* sortedListToBST(vector&lt;int&gt;&amp; v, int s, int e) { if(s == e) { return new TreeNode(v[s]); } else if(s &gt; e) { return NULL; } int m = (s+e)/2; TreeNode* root = new TreeNode(v[m]); root-&gt;left = sortedListToBST(v, s, m-1); root-&gt;right = sortedListToBST(v, m+1, e); return root; }}; 시간복잡도는 따라서 O(n)이 된다. Solution 2: Recursion2번은 1번의 경우와 비슷하지만 배열로 변환하지 않은 버전이다. 1번 솔루션과 비슷하다. 단지 다른 점이라고 하면 루트를 먼저 만드는게 아니라 노드의 left를 먼저 구하고 root를 설정하고 right를 구한다. 이를 recursive 하게 진행하면 된다. 이 방법은 단번에 생각해내기 어렵다.. 12345678910111213141516171819202122232425class Solution {public: TreeNode* sortedListToBST(ListNode* head) { if(!head) return NULL; int c = 0; ListNode* cur = head; while(cur) { c++; cur = cur-&gt;next; } return makeBST(head, 0, c - 1); } TreeNode* makeBST(ListNode*&amp; head, int s,int e) { if(s &gt; e) return NULL; int mid = (s+e)/2; TreeNode* left = makeBST(head, s, mid-1); TreeNode* root = new TreeNode(head-&gt;val); root-&gt;left = left; head = head-&gt;next; root-&gt;right = makeBST(head, mid+1, e); return root; } }; Time complexity 는 O(n) 이다. 이는 Solution 1과 같지만 Space Complexity가 O(1)으로 O(n)인 1번 솔루션에 비해 더 좋다고 할 수 있다. 관련 지식다음 3가지의 트리 순회 방법에 대해서 제대로 숙지하는 것이 좋을 것 같다. Inorder Preorder Postorder","link":"/2019/04/24/2019-04-24-leetcode-109/"},{"title":"Construct Binary Tree from Preorder and Inorder Traversal","text":"Construct Binary Tree from Preorder and Inorder Traversal Solution : RecursionPreorder과 Inorder를 가지고 트리를 구성하기 위해서는 Recursion과 각각 순회방법에 대한 특징에 대한 이해가 필요하다. Preorder 의 경우 부모 - left - right 순서이고, Inorder 는 left - 부모 - right 순서이다. 그렇다면 잘 생각해보면, preorder 순서의 제일 왼쪽의 있는 요소는 현재 트리의 루트라고 할 수 있다. 그리고 그 루트를 inorder 배열에서 찾는다. 이때 찾은 인덱스를 c라고 하면,0c-1까지가 left 서브트리의 inorder이고, c+1끝까지가 right 서브트리의 inorder이다. 그리고 preorder에서 다음 index는 left 서브트리의 루트 혹은 서브트리가 없을 경우(c == 0) right 서브트리의 루트라고 할 수 있다. 이를 통하여 트리를 만들 수 있다. 1234567891011121314TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) { int k = 0; return buildTree(preorder, inorder, 0, preorder.size()-1, k);}TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder, int s, int e, int&amp; k) { if(s &gt; e || k &gt;= preorder.size()) return NULL; TreeNode* root = new TreeNode(preorder[k]); int c = s; while(c &lt;= e &amp;&amp; preorder[k] != inorder[c]) c++; k++; root-&gt;left = buildTree(preorder, inorder, s, c-1, k); root-&gt;right = buildTree(preorder, inorder ,c+1, e, k); return root;} 참고로, preorder과 inorder의 index는 다름을 주의하자. 많이 헷갈린다. Relatedleetcode 106","link":"/2019/04/29/2019-04-29-leetcode-105/"},{"title":"Surrounded Regions","text":"Surrounded Regions Solution 1. BFS간단하게 BFS를 이용하면 해결되는 문제이다. 우선 X로 둘러 싸여져 있지 않다는 의미는 무엇일까? 그것은 바로 어떤 O 하나 혹은 여러개가 보드 가장자리에 있다는 것이다. 즉, O를 만나면 BFS로 탐색하여 이 가장자리가 있는 O를 발견하지 않으면 방문했던 노드들을 flip 시켜주면 된다. 이미 방문 했던 노드들은 V라는 문자로 바꿔주었다 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution {public: bool canMove(vector&lt;vector&lt;char&gt;&gt;&amp; board, int y,int x, bool flip) { return (y &gt;= 0 &amp;&amp; y &lt; board.size()) &amp;&amp; (x &gt;= 0 &amp;&amp; x &lt; board[0].size()) &amp;&amp; ((!flip &amp;&amp; board[y][x] == 'O') || (flip &amp;&amp; board[y][x] == 'V')); } bool bfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int y, int x, bool flip) { bool ret = true; queue&lt;pair&lt;int,int&gt;&gt; q; q.push(make_pair(y,x)); board[y][x] = flip ? 'X' : 'V'; while(!q.empty()) { auto p = q.front(); q.pop(); if(!flip) { if(p.first == 0 || p.second == 0 || p.first == board.size()-1 || p.second == board[0].size()-1) { ret = false; } } if(canMove(board, p.first+1, p.second,flip)) { q.push(make_pair(p.first+1, p.second)); board[p.first+1][p.second] = flip ? 'X' : 'V'; } if(canMove(board, p.first-1, p.second,flip)) { q.push(make_pair(p.first-1, p.second)); board[p.first-1][p.second] = flip ? 'X' : 'V'; } if(canMove(board, p.first, p.second+1,flip)) { q.push(make_pair(p.first, p.second+1)); board[p.first][p.second+1] = flip ? 'X' : 'V'; } if(canMove(board, p.first, p.second-1,flip)) { q.push(make_pair(p.first, p.second-1)); board[p.first][p.second-1] = flip ? 'X' : 'V'; } } return ret; } void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) { for(int i=0;i&lt;board.size();i++) { auto&amp; v = board[i]; for(int j=0;j&lt;v.size();j++) { if(v[j] == 'O') { if(bfs(board, i, j, false)) { bfs(board, i, j, true); } } } } for(int i=0;i&lt;board.size();i++) { for(int j=0;j&lt;board[i].size();j++) { if(board[i][j] == 'V') board[i][j] = 'O'; } } }}; 잘못 짯던 부분BFS를 가지고 Q를 이용해 탐색시에는 큐에 넣은 후에 Visited 체크를 꼭 해주자. 안그러면 타임아웃","link":"/2019/05/18/2019-05-18-leetcode-130/"},{"title":"Two Sum","text":"Given a sorted array of integers and an integer n, find a pair of elements which sum is n.For example, Let’s say the array is [1,2,4,5] and n is 9, then the answer would be [4,5]. Solution12345678910111213pair&lt;int,int&gt; twoSum(vector&lt;int&gt;&amp; nums, int sum) { int l = 0, r = nums.size() - 1; while(l &lt; r) { if(nums[l]+nums[r] &gt; sum) { r -= 1; } else if (nums[l]+nums[r] == sum) { return make_pair(nums[l], nums[r]); } else { l += 1; } } return make_pair(0, 0);} Time Complexitysince in every iteration, it moves forward or backward and it does until the left is greater than or equal to the right, the time complexity is O(n)","link":"/2019/04/05/2019-04-05-two-sum/"},{"title":"Longest Consecutive Sequence","text":"Longest Consecutive Sequence Solution 1. Hash set and intelligent sequence building배열에 있는 모든 수를 우선 Hash Set에다가 넣는다. 그리고 하나씩 조회하면서 그 이전수 예를 들어 5를 조회 한다고 가정하면 4가 현재 Set에 있는지 확인한다. 없으면 해당 숫자가 시퀀스의 맨 처음 숫자인 것이라고 할 수 있다. 이때 그 숫자부터 시작하여 몇개의 숫자가 연속되어 있는지 세기만 하면 된다. 123456789101112131415161718class Solution {public: int longestConsecutive(vector&lt;int&gt;&amp; nums) { int ans = 0; unordered_set&lt;int&gt; sets; for(int s : nums) { sets.insert(s); } for(int s : sets) { if(s == INT_MIN || sets.find(s-1) == sets.end()) { int cnt = 0; while(s != INT_MAX &amp;&amp; sets.find(s++) != sets.end()) cnt++; ans = max(ans, cnt); } } return ans; }};","link":"/2019/05/29/2019-05-29-leetcode-128/"},{"title":"Permutation in String","text":"Permutation in String Solution : Sliding windowS1과 S2 각각 알파벳 빈도수를 구하고 이를 오른쪽으로 Sliding 하면서 계속 비교해준다.알파벳이 아니라면 int 배열 대신 unordered_map 을 사용하면 되겠지만 문제에서는 알파벳만 사용했기때문에 int 배열을 사용하는게 좋다. 12345678910111213141516171819202122232425262728293031323334353637class Solution {public: bool checkInclusion(string s1, string s2) { int maps[26] = {0}; int maps2[26] = {0}; if(s1.size() &gt; s2.size()) return false; for (int i=0;i&lt;s1.size();i++) { maps[s1[i]-'a'] += 1; maps2[s2[i]-'a'] += 1; } int cnt = 0; for(int i = 0;i&lt;26;i++) { if(maps[i] == maps2[i]) cnt++; } if (cnt == 26) return true; for(int i=s1.size();i &lt; s2.size();i++) { int c = s2[i-s1.size()] - 'a'; int d = s2[i] - 'a'; if(maps[c] == maps2[c]) { cnt--; } if(maps[d] == maps2[d]) { cnt--; } maps2[c]--; maps2[d]++; if(maps[c] == maps2[c]) { cnt++; } if(maps[d] == maps2[d]) { cnt++; } if(cnt == 26) return true; } return cnt == 26; }}; O(S2)","link":"/2019/05/22/2019-05-22-leetcode-567/"},{"title":"Triangle","text":"Triangle Solution 1. Recursion (TLE)가장 무식하면서도 간단한 방법은 Recursion을 이용해 모든 경우의 수를 다 돌아 보는 것이다. 현재 위치가 y, x에 있다면, y+1,x+1에서 갈때의 최소값과 y+1, x에서 갈때의 최소값을 비교해서 작은 것을 선택하면 된다. 1234567891011121314151617class Solution {public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle, int height, int cur) { if(cur &lt; 0 || cur &gt;= triangle[height].size()) return INT_MAX; if(height == triangle.size()-1) { return triangle[height][cur]; } return triangle[height][cur] + min(minimumTotal(triangle, height+1, cur), minimumTotal(triangle, height+1, cur+1)); } int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) { return minimumTotal(triangle, 0, 0); }}; 하지만 이렇게 하면 TLE가 난다. 너무 느리다. 최적화가 필요하다. Solution 2. Recursion + Cacheing겹치는 부분을 잘 살펴보자. 예를 들어 다음과 같은 트라이앵글이 존재한다고 가정하자 123456[ [2], [3,4], [6,5,7], [4,1,8,3]] 예를 들어 2번째 줄인 3,4 는 5를 공유한다. 따라서 3에서 이미 값을 구했다면 4에서는 이를 구할 필요가 없다. 이를 잘 저장하고 있다가 다시 쓰면 굳이 다시 구하지 않아도 된다. 123456789101112131415161718192021222324class Solution {public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle, vector&lt;vector&lt;int&gt;&gt;&amp; cache, int height, int cur) { if(cur &lt; 0 || cur &gt;= triangle[height].size()) return INT_MAX; while(cache[height].size() &lt;= cur) cache[height].push_back(INT_MAX); if(height == triangle.size()-1) { return triangle[height][cur]; } if(cache[height][cur] != INT_MAX) { return cache[height][cur]; } return cache[height][cur] = triangle[height][cur] + min(minimumTotal(triangle,cache, height+1, cur), minimumTotal(triangle,cache, height+1, cur+1)); } int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) { vector&lt;vector&lt;int&gt;&gt; cache; for(int i=0;i&lt;triangle.size();i++) { cache.push_back({}); } return minimumTotal(triangle,cache, 0, 0); }}; Time complexity, Space complexity는 O(n) 이 된다, (n은 모든 원소의 개수이다.)","link":"/2019/05/23/2019-05-23-leetcode-120/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/06/01/hello-world/"},{"title":"SWE & ML Collections","text":"주요 사이트 deeplearning.ai 카카오브레인 State-of-the-Art for dl 44bits.io/ko 도움되는 글 (AI) AI 최신 동향 머신러닝 공부순서 Key trends from NeurIPS 2019 Rules of Machine Learning: Best Practices for ML Engineering Fullstack of Deep learning, 딥러닝 레퍼런스 Pytorch 논문 LF AI Foundation Interactive Landscape 인공지능, 통계 관련 유용한 무료 강의 &amp; 책 모음 논문 읽기와 ML/DL 커리어 경력에 대한 조언 by Andrew Ng Graph Theory Algorithms Machine Learning 정리 도움 되는 글 (SWE) 만들면서 이해하는 도커 이미지의 구조","link":"/2019/12/27/swe-ml-collection/"},{"title":"2020년의 계획","text":"올해 전반 계획 논문 읽기 스터디 (매주) leetcode 화이트 보드 연습 배운 것들을 블로그에 써가는 습관 운동 ( 기초 체력 단련 위주 ) 1일 1커밋 1월 ~ 3월 풀잎교실 수학 수업 GRE 4월 ~ 10월 Coursera, Advanced Machine Learning GRE10월 ~ 12월 토플","link":"/2019/12/27/2020-resolution/"},{"title":"2019년도의 회고 그리고 반성","text":"서론길고 길던 2019년이 지났고, 나는 마침내 군대+휴학 포함 8년을 다니던 대학교를 졸업한다. 대학생의 나는 그다지 만족스러운 생활을 보내지 못한 것 같아 아쉬운 마음이 든다. 끝끝내 성적 괜찮고 취업도 괜찮은 곳으로 들어간 것 같지만, 아쉬운 점이 많은 대학 생활이었다고 생각한다. 하지만, 이미 지난 것을 어찌하겠는가. 뒤를 돌아보지 말고 앞으로 잘해내가면 된다고 믿는다. 한 일들1~2월1~2월에는 라인에서 인턴을 했다. Netty 개발자로 유명하신 희승님이 개발하고 계시는 Armeria 라고하는 오픈소스를 개발하는 팀에 들어가서 기여하는 프로젝트를 했다. (생애 처음으로 오픈소스에 기여를 해보았다.)오픈소스에는 생각보다 많은 노력과 관심을 필요로 한다. Pull Request를 보내면 거기서 부터 시작이다. 개인적으로 오픈소스에 기여하시는 분은 대단하다고 생각이 든다. 비록 지금은 좀 많이 다른 분야를 택하게 되서 그 팀에 가서 일할 수는 없지만, 인턴 기간동안 희승님을 만나서 같이 일해본 것은 뜻깊은 경험이었다. 희승님 실력이야 당연히 좋으시지만, 내가 꽤나 감명깊게 본 것은 커뮤니케이션 능력이 아닌가 싶다. 그 정도 실력, 높이에 있으면 어느정도 자만을 하는 경우가 많은데, 그런 느낌을 못느꼈고, 어떤 사람이 와서도 잘 이끌어 주실 것 같은 느낌이 들었다. 나머지 팀원 분들도 굉장히 실력있고 좋은 분들이었기에 인턴 생활을 꽤나 즐겁게 할 수 있었던것 같다. 3월 ~ 6월4학년 1학기, 딱히 크게 기억이 남는 것은 없다. 추후에 나를 꽤나 괴롭힌 ~RealGraph 라고하는 졸업프로젝트를 시작했고 삼성 리서치, 라인 인턴 전환 면접을 보았다. 둘 다 결과는 좋지 않았다. 삼성 리서치는 직무와 창의 면접은 아주 좋게 봤으나, 임원 면접을 너무 망쳐버렸고 ( 삼성은 임원 면접의 비율이 높다고 하는데, 사실인가 보다. ), 라인 인턴 전환 면접은 내가 준비를 제대로 하지 못했다. (라인은 인턴 전환의 비율이 많이 낮다고 한다.) 사실 3월 부터의 느낌은 이미 안좋았던것 같다. (올해는 뭔가 망한 느낌) 개인적인 사건 사고도 여러 터졌었고, 이때부터 올해 내내 근심과 우울증에 시달렸던 것 같다. 7월 ~ 8월4학년 마지막 여름방학은, 내가 가장 후회하는 방학이 아닌가 싶다. 정말 거의 기억이 없다. 스터디 몇개를 했지만, 다 어영부영 하다가 끝나버렸고, 독일 스타트업과 카카오 프론트앤드 경력직 면접을 봤는데 결과가 역시 좋지 않았다. 사실 이때 토플이나 GRE 준비를 했어야 했다. 내 마음은 대학원을 갈지 취업을 할지 계속 고민 하는 상태였고, 졸업프로젝트 있다고 해서 할 수 있음에도 계속 시간이 없다는 핑계를 댄것 같다. 결국 나는 취업도 대학원 준비도 제대로 하지 못한채 방학을 끝냈다. 9월 ~ 12월9월 부터는 제대로된 취업 준비를 시작했다. 여러번 면접을 봤던 자료와 부족한 점을 모아서 뭐가 부족한지 고민해보고 보충했다. 삼성 같은 우리나라 3대 대기업 같은 곳은 내가 원하지 않았고, 네이버, 카카오, 스타트업 위주로 지원을 했다. 네이버는 공채와 교수님의 추천으로 하는 전환 인턴, 카카오는 공채를 지원(카카오 브레인)하게 되었다. 스타트업은 외국에 여러 지사를 가지고 있는 M사 시애틀 지점으로 지원을 했다. 결과는 네이버 공채를 제외한 모두 통과할 수 있었다. 결과적으로 카카오브레인으로 가기로 결정 했다. 카카오브레인을 결정한 이유는 앞으로의 진로를 인공지능쪽으로 결정했기 때문이다. 물론 대학원을 갈 수도 있지만, 굳이 이미 그쪽으로 취업한 거 대학원을 갈 필요가 있을까 생각했다. 특히나, 대학원은 별 생각없이 가는 곳이 아니다. 아직까지 나는 뭘 연구를 하고 싶은지, 어떤 걸 하고 싶은지 구체적인 플랜이 없으면 석사를 해도 별 의미가 없을 것이다. 그게 정해져야 대학원을 가야할지 말아야 할지 생각해야 하는게 아닐까? 성공한 것올해 뿐만 아니라, 대학교 내내 그나마 성공한 것은 성적이 아닐까 싶다. (사실 이것도 대학원 가는게 없으면 그다지 필요가 없다..) 그리고 아마.. 취업? 딱히 이번 년도에 성공한 게 없다. 실패한 것 운동 그냥 안했다. 그냥 내가 게을러서 그렇다. 대학원 준비 그냥 각만 재다가 아무것도 안했다. 나는 참 한심하구나 공부 학과 공부말고는 딱히 아무것도 안한 것 같다. 졸업프로젝트 졸업프로젝트는 프로젝트 말고 논문을 골랐어야 한다. 그래야 남는게 있다. 나는 왜 실패 했는가.나는 왜 실패했는가 올해 마지막으로 고민해본다. 독학 (비강제성), 의지박약, 게으름, 열정 부족 고등학교 때의 나는, 굉장히 부지런했는데, 난 왜 이렇게 된걸까?, 아마 자발적으로 공부하는 습관이 없어서 그렇게 된게 아닐까 싶다. 일단 지르고 강제적으로 할 수 있는 수단을 찾아야 겠다. 일단 집에서 벗어나야 한다. 우유부단 올해의 나는 백앤드로 갈거냐, 머신러닝으로 갈거냐를 계속 고민했고, 또 대학원이냐 취업이냐를 계속 고민해왔다. 물론 중요한 것이지만, 굳이 이렇게 오래 고민할 필요가 있엇을까? 자만 나는 겸손하지 못했다. 상대방이 어리든, 이제 막 시작한 초보이던, 배울점이 있는 사람이 있다. 머리로는 알고 있지만, 나는 본능적으로 그런 사람들을 그다지 존중하지 못했던것 같다. 내 실력에 대한 자만이 너무 컸다. 수업을 들어도 내가 잘 모르는 내용에만 집중하고, 아는 내용에는 그다지 집중하지 않았다. 책 같은 것은 한번 보면 해봤자 20~30% 정도 밖에 기억에 남지 않는다. 내가 고등학교 때 기출문제집 20번을 넘게 풀어서 성공했던 것 처럼, 책도 여러번 봐야 하는게 아닌가 싶다. 특히나 좋은 책들은 더더욱 그러하다. 앞으로는 경쟁하지 말고 성장하라. 표면적으로는, 우리는 서로 경쟁하고 있다고 생각하지만, 사실 나와의 싸움인 경우가 많다. 그게 수능이던, 취직이던, 결국은 나 자신과의 싸움에서 이겨내어 성장하는 것이다. 남의 성공에 너무 질투심 느끼고, 시기할 필요가 없다. 바로 성공할 수 있는 사람은 없다. 성장하다보면 때가 되면 알아서 기회가 오리라. 운동하라 체력이 부족하면 사람이 나태해지고, 동기부여가 되지 않는다. 3대 500 찍는 다던지 그럴 필요 없이, 기초 체력을 기르기 위한 운동을 하자. 행동으로 옮겨라 살면서 가장 후회했던 것. 고민만 하다가 결국은 행동하지 못한 것. 겸손하라","link":"/2019/12/31/2019-retrospect/"}],"tags":[{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"cpp","slug":"cpp","link":"/tags/cpp/"},{"name":"hello","slug":"hello","link":"/tags/hello/"},{"name":"first","slug":"first","link":"/tags/first/"},{"name":"machine-learning","slug":"machine-learning","link":"/tags/machine-learning/"},{"name":"deep-learning","slug":"deep-learning","link":"/tags/deep-learning/"},{"name":"swe","slug":"swe","link":"/tags/swe/"},{"name":"resolution","slug":"resolution","link":"/tags/resolution/"},{"name":"retrospect","slug":"retrospect","link":"/tags/retrospect/"}],"categories":[{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"},{"name":"hello","slug":"hello","link":"/categories/hello/"},{"name":"ai","slug":"ai","link":"/categories/ai/"},{"name":"life","slug":"life","link":"/categories/life/"}]}
{"pages":[{"title":"","text":"Hello?","link":"/about.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/06/01/hello-world/"},{"title":"Binary Tree Level Order Traversal","text":"Binary Tree Level Order Traversal Solution 1. Recursive이 문제는 Medium 이지만 Easy에 가깝다. 재귀적 방법을 이용하면 풀 수 있다. 2차원 배열 vector를 선언하고 현재 노드의 레벨을 lv라고 했을 때 현재 lv 만큼의 버켓이 없다면 버켓을 생성해주고, lv 인덱스 버켓에 현재 노드의 값을 저장한다. 이 과정을 왼쪽과 오른쪽 노드에도 똑같이 반복하면 된다. 소스코드는 다음과 같다. 12345678910111213vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { vector&lt;vector&lt;int&gt;&gt; buckets; levelOrder(root, buckets, 0); return buckets;}void levelOrder(TreeNode* root, vector&lt;vector&lt;int&gt;&gt;&amp; buckets, int lv) { if(root == NULL) return; while(buckets.size() &lt;= lv) buckets.push_back({}); buckets[lv].push_back(root-&gt;val); levelOrder(root-&gt;left, buckets, lv+1); levelOrder(root-&gt;right, buckets, lv+1);} 시간복잡도는 n을 총 노드의 갯수라고 가정 했을 때 O(n)이 된다. Solution 2. Queue두번째 해결방법은 Queue 두개를 이용한 방법이다. (사실 하나로도 해결할 수는 있지만 그냥 두개를 이용하는게 편하다.) 이는 BFS를 생각하면 된다. Q1에는 현재 레벨의 노드들이 들어가 있고, Q2에는 다음 레벨의 노드들을 차례대로 담는 것이다. 그리고 현재 레벨이 끝나면 Q2를 Q1으로 바꾸고 이를 반복하면 된다. 123456789101112131415161718192021vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { vector&lt;vector&lt;int&gt;&gt; r; if(root == NULL) return r; queue&lt;TreeNode*&gt; _q[2]; int lv = 0; _q[0].push(root); while(!_q[0].empty() || !_q[1].empty()) { queue&lt;TreeNode*&gt; &amp;src = _q[lv % 2]; queue&lt;TreeNode*&gt; &amp;dst = _q[(lv+1) % 2]; r.push_back({}); while(!src.empty()) { TreeNode* c = src.front(); r[lv].push_back(c-&gt;val); src.pop(); if(c-&gt;left) dst.push(c-&gt;left); if(c-&gt;right) dst.push(c-&gt;right); } lv++; } return r;} 사실 이 방법이 1번 방법보다는 다소 복잡한 감이 없지않아 있지만 문제의 의도와는 비슷하다고 볼 수 있다. Relatedleetcode 103 Advanced Questions? 결과 값은 다 메모리에 들어갈 수 있지만, 트리가 메모리 안에 들어갈 수 없다면 어떻게 할까? 메모리 안에 들어갈 수 없다면 별도로 chunk 별로 나누어서 저장해야 한다. 여기서 주의해야 할 점은 노드 정보에서 자식 노드들의 정보는 메모리 값이 아니라 파일 인덱스가 될 수도 있다는 점이다. 그리고 chunk를 저장하는 방법도 성능에 중요한 영향을 미칠 수 있다. 내 생각에는 $$2^n - 1$$개를 하나의 chunk로 삼아서 저장하면 될 거 같다. 예를들어 레벨이 총 6개까지 있을때 레벨 13 까지 1개의 chunk, 레벨 46까지 8개의 chunk가 생기므로 총 9개의 chunk가 생긴다고 생각 하면된다.","link":"/2019/04/23/2019-04-23-leetcode-102/"},{"title":"Two Sum","text":"Given a sorted array of integers and an integer n, find a pair of elements which sum is n.For example, Let’s say the array is [1,2,4,5] and n is 9, then the answer would be [4,5]. Solution12345678910111213pair&lt;int,int&gt; twoSum(vector&lt;int&gt;&amp; nums, int sum) { int l = 0, r = nums.size() - 1; while(l &lt; r) { if(nums[l]+nums[r] &gt; sum) { r -= 1; } else if (nums[l]+nums[r] == sum) { return make_pair(nums[l], nums[r]); } else { l += 1; } } return make_pair(0, 0);} Time Complexitysince in every iteration, it moves forward or backward and it does until the left is greater than or equal to the right, the time complexity is O(n)","link":"/2019/04/05/2019-04-05-two-sum/"},{"title":"LeetCode - Best Time to Buy and Sell Stock III","text":"Say you have an array for which the $i^{th}$ element is the place of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: 123Input: [3,3,5,0,0,3,1,4]Output: 6Explanation: Buy on day 4 (price = 0) and sell on day 6(price = 3), profit = 3 - 9 = 3, Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4 - 1 = 3 Example 2: 12Input: [1,2,3,4,5]Output: 4 Example 3: 12Input: [7,6,4,3,1]Output: 0 Solution 1. Brute Force우선 가장 쉬운 문제 해결 방법은 Brute Force 방법이다. 이중 포문을 이용하여 첫번째 거래를 찾는다 (i &lt; j &amp;&amp; prices[i] &lt; prices[j]) 그 다음 j+1부터 n-1까지 두번째 거래를 마찬가지로 이중 포문을 이용하여 찾는다. 12345678910111213141516int maxProfit(vector&lt;int&gt;&amp; prices) { return maxProfit(prices, 0, 2);}int maxProfit(vector&lt;int&gt;&amp; prices, int s, int k) { int ans = 0; if(k == 0) return 0; for(int i = s;i &lt; prices.size(); i++) { for(int j = i+1; j &lt; prices.size();j++) { if(prices[i] &lt; prices[j]) { ans = max(ans, prices[j]-prices[i] + maxProfit(prices, j+1, k-1)); } } } return ans;} 하지만, 이러한 방법은 시간복잡도가 O($$n^4$$) 가 된다는 단점이 있다. Solution 2. 뒤에서 계산하기이 방법은 필자가 처음으로 생각해낸 방법이다. 뒤에서 부터 mx array를 계산하는 것이다. 여기서 mx array는 mx[i] = i 부터 시작한다고 가졍하고 한번만 거래하는 경우의 최대값 이때 mx[i] = max( mx[i+1] , i~끝까지의 최대값 - prices[i] )이다. 이렇게 구한 mx 배열을 이용해서 최대 두번 거래할때의 최대값을 구할 수 있다. 이는 0부터 시작하면서, i 번째 값은 $$profit_i = max(profit_{i-1}, mx[i+1] + prices[i] - mn)$$, 여기서 mn은 prices[0~i] 까지의 최소값 코드로 구현하면 다음과 같다. 123456789101112131415int maxProfit(vector&lt;int&gt;&amp; prices) { if(prices.size() == 0) return 0; vector&lt;int&gt; mx(prices.size()+1); int cur_mx = INT_MIN, cur_mn = INT_MAX; int ans = 0; for(int i = prices.size() - 1; i &gt;= 0; i--) { cur_mx = max(prices[i], cur_mx); mx[i] = max(mx[i+1], cur_mx - prices[i]); } for(int i = 0; i &lt; prices.size(); i++) { cur_mn = min(prices[i], cur_mn); ans = max(ans, mx[i+1] + prices[i] - cur_mn); } return ans;} 여기서 시간복잡도는 O($$n$$) 이고, 공간복잡도 역시 O($$n$$) 이다.더 좋은 방법이 있을듯.","link":"/2019/04/22/2019-04-22-leetcode-123/"},{"title":"Construct Binary Tree from Preorder and Inorder Traversal","text":"Construct Binary Tree from Preorder and Inorder Traversal Solution : RecursionPreorder과 Inorder를 가지고 트리를 구성하기 위해서는 Recursion과 각각 순회방법에 대한 특징에 대한 이해가 필요하다. Preorder 의 경우 부모 - left - right 순서이고, Inorder 는 left - 부모 - right 순서이다. 그렇다면 잘 생각해보면, preorder 순서의 제일 왼쪽의 있는 요소는 현재 트리의 루트라고 할 수 있다. 그리고 그 루트를 inorder 배열에서 찾는다. 이때 찾은 인덱스를 c라고 하면,0c-1까지가 left 서브트리의 inorder이고, c+1끝까지가 right 서브트리의 inorder이다. 그리고 preorder에서 다음 index는 left 서브트리의 루트 혹은 서브트리가 없을 경우(c == 0) right 서브트리의 루트라고 할 수 있다. 이를 통하여 트리를 만들 수 있다. 1234567891011121314TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) { int k = 0; return buildTree(preorder, inorder, 0, preorder.size()-1, k);}TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder, int s, int e, int&amp; k) { if(s &gt; e || k &gt;= preorder.size()) return NULL; TreeNode* root = new TreeNode(preorder[k]); int c = s; while(c &lt;= e &amp;&amp; preorder[k] != inorder[c]) c++; k++; root-&gt;left = buildTree(preorder, inorder, s, c-1, k); root-&gt;right = buildTree(preorder, inorder ,c+1, e, k); return root;} 참고로, preorder과 inorder의 index는 다름을 주의하자. 많이 헷갈린다. Relatedleetcode 106","link":"/2019/04/29/2019-04-29-leetcode-105/"},{"title":"Convert Sorted List to Binary Search Tree","text":"Convert Sorted List to Binary Search Tree Solution 1: Convert To Array and Recursion afterward입력이 LinkedList 로 주어진다. 잘 생각해보면 정렬된 배열 -&gt; BST로 바꾸는 것은 간단하다. 해당 배열의 맨 중간 값을 현재 노드의 값으로 선택하고 왼쪽 서브 배열, 오른쪽 서브 배열에 대해서 각각 Recursion으로 해결해주면 된다. 1234567891011121314151617181920212223class Solution {public: TreeNode* sortedListToBST(ListNode* head) { vector&lt;int&gt; v; while(head != NULL) { v.push_back(head-&gt;val); head = head-&gt;next; } return sortedListToBST(v, 0, v.size()-1); } TreeNode* sortedListToBST(vector&lt;int&gt;&amp; v, int s, int e) { if(s == e) { return new TreeNode(v[s]); } else if(s &gt; e) { return NULL; } int m = (s+e)/2; TreeNode* root = new TreeNode(v[m]); root-&gt;left = sortedListToBST(v, s, m-1); root-&gt;right = sortedListToBST(v, m+1, e); return root; }}; 시간복잡도는 따라서 O(n)이 된다. Solution 2: Recursion2번은 1번의 경우와 비슷하지만 배열로 변환하지 않은 버전이다. 1번 솔루션과 비슷하다. 단지 다른 점이라고 하면 루트를 먼저 만드는게 아니라 노드의 left를 먼저 구하고 root를 설정하고 right를 구한다. 이를 recursive 하게 진행하면 된다. 이 방법은 단번에 생각해내기 어렵다.. 12345678910111213141516171819202122232425class Solution {public: TreeNode* sortedListToBST(ListNode* head) { if(!head) return NULL; int c = 0; ListNode* cur = head; while(cur) { c++; cur = cur-&gt;next; } return makeBST(head, 0, c - 1); } TreeNode* makeBST(ListNode*&amp; head, int s,int e) { if(s &gt; e) return NULL; int mid = (s+e)/2; TreeNode* left = makeBST(head, s, mid-1); TreeNode* root = new TreeNode(head-&gt;val); root-&gt;left = left; head = head-&gt;next; root-&gt;right = makeBST(head, mid+1, e); return root; } }; Time complexity 는 O(n) 이다. 이는 Solution 1과 같지만 Space Complexity가 O(1)으로 O(n)인 1번 솔루션에 비해 더 좋다고 할 수 있다. 관련 지식다음 3가지의 트리 순회 방법에 대해서 제대로 숙지하는 것이 좋을 것 같다. Inorder Preorder Postorder","link":"/2019/04/24/2019-04-24-leetcode-109/"},{"title":"Surrounded Regions","text":"Surrounded Regions Solution 1. BFS간단하게 BFS를 이용하면 해결되는 문제이다. 우선 X로 둘러 싸여져 있지 않다는 의미는 무엇일까? 그것은 바로 어떤 O 하나 혹은 여러개가 보드 가장자리에 있다는 것이다. 즉, O를 만나면 BFS로 탐색하여 이 가장자리가 있는 O를 발견하지 않으면 방문했던 노드들을 flip 시켜주면 된다. 이미 방문 했던 노드들은 V라는 문자로 바꿔주었다 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution {public: bool canMove(vector&lt;vector&lt;char&gt;&gt;&amp; board, int y,int x, bool flip) { return (y &gt;= 0 &amp;&amp; y &lt; board.size()) &amp;&amp; (x &gt;= 0 &amp;&amp; x &lt; board[0].size()) &amp;&amp; ((!flip &amp;&amp; board[y][x] == 'O') || (flip &amp;&amp; board[y][x] == 'V')); } bool bfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int y, int x, bool flip) { bool ret = true; queue&lt;pair&lt;int,int&gt;&gt; q; q.push(make_pair(y,x)); board[y][x] = flip ? 'X' : 'V'; while(!q.empty()) { auto p = q.front(); q.pop(); if(!flip) { if(p.first == 0 || p.second == 0 || p.first == board.size()-1 || p.second == board[0].size()-1) { ret = false; } } if(canMove(board, p.first+1, p.second,flip)) { q.push(make_pair(p.first+1, p.second)); board[p.first+1][p.second] = flip ? 'X' : 'V'; } if(canMove(board, p.first-1, p.second,flip)) { q.push(make_pair(p.first-1, p.second)); board[p.first-1][p.second] = flip ? 'X' : 'V'; } if(canMove(board, p.first, p.second+1,flip)) { q.push(make_pair(p.first, p.second+1)); board[p.first][p.second+1] = flip ? 'X' : 'V'; } if(canMove(board, p.first, p.second-1,flip)) { q.push(make_pair(p.first, p.second-1)); board[p.first][p.second-1] = flip ? 'X' : 'V'; } } return ret; } void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) { for(int i=0;i&lt;board.size();i++) { auto&amp; v = board[i]; for(int j=0;j&lt;v.size();j++) { if(v[j] == 'O') { if(bfs(board, i, j, false)) { bfs(board, i, j, true); } } } } for(int i=0;i&lt;board.size();i++) { for(int j=0;j&lt;board[i].size();j++) { if(board[i][j] == 'V') board[i][j] = 'O'; } } }}; 잘못 짯던 부분BFS를 가지고 Q를 이용해 탐색시에는 큐에 넣은 후에 Visited 체크를 꼭 해주자. 안그러면 타임아웃","link":"/2019/05/18/2019-05-18-leetcode-130/"},{"title":"Permutation in String","text":"Permutation in String Solution : Sliding windowS1과 S2 각각 알파벳 빈도수를 구하고 이를 오른쪽으로 Sliding 하면서 계속 비교해준다.알파벳이 아니라면 int 배열 대신 unordered_map 을 사용하면 되겠지만 문제에서는 알파벳만 사용했기때문에 int 배열을 사용하는게 좋다. 12345678910111213141516171819202122232425262728293031323334353637class Solution {public: bool checkInclusion(string s1, string s2) { int maps[26] = {0}; int maps2[26] = {0}; if(s1.size() &gt; s2.size()) return false; for (int i=0;i&lt;s1.size();i++) { maps[s1[i]-'a'] += 1; maps2[s2[i]-'a'] += 1; } int cnt = 0; for(int i = 0;i&lt;26;i++) { if(maps[i] == maps2[i]) cnt++; } if (cnt == 26) return true; for(int i=s1.size();i &lt; s2.size();i++) { int c = s2[i-s1.size()] - 'a'; int d = s2[i] - 'a'; if(maps[c] == maps2[c]) { cnt--; } if(maps[d] == maps2[d]) { cnt--; } maps2[c]--; maps2[d]++; if(maps[c] == maps2[c]) { cnt++; } if(maps[d] == maps2[d]) { cnt++; } if(cnt == 26) return true; } return cnt == 26; }}; O(S2)","link":"/2019/05/22/2019-05-22-leetcode-567/"},{"title":"Triangle","text":"Triangle Solution 1. Recursion (TLE)가장 무식하면서도 간단한 방법은 Recursion을 이용해 모든 경우의 수를 다 돌아 보는 것이다. 현재 위치가 y, x에 있다면, y+1,x+1에서 갈때의 최소값과 y+1, x에서 갈때의 최소값을 비교해서 작은 것을 선택하면 된다. 1234567891011121314151617class Solution {public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle, int height, int cur) { if(cur &lt; 0 || cur &gt;= triangle[height].size()) return INT_MAX; if(height == triangle.size()-1) { return triangle[height][cur]; } return triangle[height][cur] + min(minimumTotal(triangle, height+1, cur), minimumTotal(triangle, height+1, cur+1)); } int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) { return minimumTotal(triangle, 0, 0); }}; 하지만 이렇게 하면 TLE가 난다. 너무 느리다. 최적화가 필요하다. Solution 2. Recursion + Cacheing겹치는 부분을 잘 살펴보자. 예를 들어 다음과 같은 트라이앵글이 존재한다고 가정하자 123456[ [2], [3,4], [6,5,7], [4,1,8,3]] 예를 들어 2번째 줄인 3,4 는 5를 공유한다. 따라서 3에서 이미 값을 구했다면 4에서는 이를 구할 필요가 없다. 이를 잘 저장하고 있다가 다시 쓰면 굳이 다시 구하지 않아도 된다. 123456789101112131415161718192021222324class Solution {public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle, vector&lt;vector&lt;int&gt;&gt;&amp; cache, int height, int cur) { if(cur &lt; 0 || cur &gt;= triangle[height].size()) return INT_MAX; while(cache[height].size() &lt;= cur) cache[height].push_back(INT_MAX); if(height == triangle.size()-1) { return triangle[height][cur]; } if(cache[height][cur] != INT_MAX) { return cache[height][cur]; } return cache[height][cur] = triangle[height][cur] + min(minimumTotal(triangle,cache, height+1, cur), minimumTotal(triangle,cache, height+1, cur+1)); } int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) { vector&lt;vector&lt;int&gt;&gt; cache; for(int i=0;i&lt;triangle.size();i++) { cache.push_back({}); } return minimumTotal(triangle,cache, 0, 0); }}; Time complexity, Space complexity는 O(n) 이 된다, (n은 모든 원소의 개수이다.)","link":"/2019/05/23/2019-05-23-leetcode-120/"},{"title":"Longest Consecutive Sequence","text":"Longest Consecutive Sequence Solution 1. Hash set and intelligent sequence building배열에 있는 모든 수를 우선 Hash Set에다가 넣는다. 그리고 하나씩 조회하면서 그 이전수 예를 들어 5를 조회 한다고 가정하면 4가 현재 Set에 있는지 확인한다. 없으면 해당 숫자가 시퀀스의 맨 처음 숫자인 것이라고 할 수 있다. 이때 그 숫자부터 시작하여 몇개의 숫자가 연속되어 있는지 세기만 하면 된다. 123456789101112131415161718class Solution {public: int longestConsecutive(vector&lt;int&gt;&amp; nums) { int ans = 0; unordered_set&lt;int&gt; sets; for(int s : nums) { sets.insert(s); } for(int s : sets) { if(s == INT_MIN || sets.find(s-1) == sets.end()) { int cnt = 0; while(s != INT_MAX &amp;&amp; sets.find(s++) != sets.end()) cnt++; ans = max(ans, cnt); } } return ans; }};","link":"/2019/05/29/2019-05-29-leetcode-128/"}],"tags":[{"name":"hello","slug":"hello","link":"/tags/hello/"},{"name":"first","slug":"first","link":"/tags/first/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"cpp","slug":"cpp","link":"/tags/cpp/"}],"categories":[{"name":"hello","slug":"hello","link":"/categories/hello/"},{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"}]}